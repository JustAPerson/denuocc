[suites.phase4]
passes = ["state_read_input", "preprocess_phase1", "preprocess_phase2", "preprocess_phase3", "preprocess_phase4"]
output_compare = "assert_pptokens_loose_equal"


################################################################################
# Macros
################################################################################

# Test just defining macros

[[suites.phase4.cases]]
input = "#define\n"
messages = ["<case>:0:0: expected `Identifier` token; found `EndOfFile`"]

[[suites.phase4.cases]]
input = "#define a"
output = ""

[[suites.phase4.cases]]
input = "#define test()"
output = ""

[[suites.phase4.cases]]
input = "#define test(...)"
output = ""

[[suites.phase4.cases]]
input = "#define test(a, b, ...)"
output = ""

[[suites.phase4.cases]]
input = "#define test(a)"
output = ""

# Test expanding macros

[[suites.phase4.cases]]
input = """
#define abc def
abc abcdef
"""
output = "def abcdef"

[[suites.phase4.cases]]
input = """
#define test()
test()
"""
output = ""

[[suites.phase4.cases]]
input = """
#define add(a, b) a + b
add(1, 3)
"""
output = "1 + 3"

[[suites.phase4.cases]]
input = """
#define object value
#define func() value
object(3)
func
"""
messages = [
  "<case>:3:0: `object` was defined as object macro but is being used as function macro",
  "<case>:4:0: `func` was defined as function macro but is being used as object macro"
]

[[suites.phase4.cases]]
input = """
#define add(a, b) a + b
add(1)
"""
messages = [
  "<case>:2:3: `add` expects exactly 2 arguments; found 1"
]

[[suites.phase4.cases]]
input = """
#define add(a, b) a + b
add(1,2,3)
"""
messages = [
  "<case>:2:3: `add` expects exactly 2 arguments; found 3"
]

[[suites.phase4.cases]]
input = """
#define add(a, b, ...) a + b
add(1,2,3,4)
"""
output = "1 + 2"

[[suites.phase4.cases]]
input = """
#define test(a, b, ...) __VA_ARGS__
test(1,2,3,4)
"""
output = "3,4"

[[suites.phase4.cases]]
input = """
#define a b
#define m(a) a
a m(1) a
"""
output = "b 1 b"

[[suites.phase4.cases]]
input = """
#define v(...) __VA_ARGS__
v()
v(1)
v(2, 3)
"""
output = "1 2 , 3"

[[suites.phase4.cases]]
input = """
#define v(a, ...) a
v()
v(0)
v(1, 2)
"""
output = "0 1"
messages = []

[[suites.phase4.cases]]
input = """
#define v(a, b, ...) a
v()
v(0)
v(1, 2)
"""
output = "0 1"
messages = [
  "<case>:2:1: `v` expects at least 2 arguments; found 1",
  "<case>:3:1: `v` expects at least 2 arguments; found 1"
]

[[suites.phase4.cases]]
input = """
#define v(a) a
v()
v(0)
"""
output = "0"
messages = []

# test undef directive

[[suites.phase4.cases]]
input = """
#define a b
a
#undef a
a
"""
output = "b a"

[[suites.phase4.cases]]
input = """
#undef 3
"""
messages = ["<case>:1:7: expected `Identifier` token; found `PPNumber`"]

[[suites.phase4.cases]]
input = """
#undef 
"""
messages = ["<case>:1:7: expected `Identifier` token; found `Whitespace`"]

# test cases from the standard

[[suites.phase4.cases]]
input = '''
#define x 3
#define f(a) f(x * (a))
#undef x
#define x 2
#define g f
#define z z[0]
#define h g(\~{ }
#define m(a) a(w)
#define w 0,1
#define t(a) a
#define p() int
#define q(x) x
#define r(x,y) x ## y
#define str(x) # x
f(y+1) + f(f(z)) % t(t(g)(0) + t)(1);
g(x+(3,4)-w) | h 5) & m
      (f)^m(m);
p() i[q()] = { q(1), r(2,3), r(4,), r(,5), r(,) };
char c[2][6] = { str(hello), str() };
'''
output = '''
f(2 * (y+1)) + f(2 * (f(2 * (z[0])))) % f(2 * (0)) + t(1);
f(2 * (2+(3,4)-0,1)) | f(2 * (\~{ } 5)) & f(2 * (0,1))^m(0,1);
int i[] = { 1, 23, 4, 5, };
char c[2][6] = { "hello", "" };
'''

################################################################################
# If directives
################################################################################

[[suites.phase4.cases]]
input = """
#ifdef UNDEFINED
a
#else
b
#endif
"""
output = "b"