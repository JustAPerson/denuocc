[suites.phase4]
passes = ["state_read_input", "preprocess_phase1", "preprocess_phase2", "preprocess_phase3", "preprocess_phase4"]
results_print = "pptokens_to_string"
results_compare = "assert_pptokens_loose_equal"


# Test that result of processing input is not empty. If it is, then the result
# of different inputs would compare equal causing this case to succeed when it
# should fail
[[suites.phase4.cases]]
input = ""
output = "no"
should_panic = true

################################################################################
# Macros
################################################################################

# Test just defining macros

[[suites.phase4.cases]]
input = "#define a"
output = ""

[[suites.phase4.cases]]
input = "#define test()"
output = ""

[[suites.phase4.cases]]
input = "#define test(a)"
output = ""

[[suites.phase4.cases]]
input = "#define test(...)"
output = ""

[[suites.phase4.cases]]
input = "#define test(a, b, ...)"
output = ""

################################################################################
# Test definition parsing errors and that they result in no definition
################################################################################

[[suites.phase4.cases]]
input = "#define\n"
messages = ["<case>:1:7: expected `Identifier` token; found `Whitespace` token"]

[[suites.phase4.cases]]
input = """
#define test(a b)
test(a)
"""
output = "test(a)"
messages = ["<case>:1:15: expected `,`; found `b`"]

[[suites.phase4.cases]]
input = """
#define test(..., a) __VA_ARGS__
test(a)
"""
output = "test(a)"
messages = ["<case>:1:16: expected `)`; found `,`"]

[[suites.phase4.cases]]
input = """
#define test(a,)
"""
messages = ["<case>:1:15: expected identifier or `...`; found `)`"]

[[suites.phase4.cases]]
input = "#define macro(a, a) a"
messages = ["<case>:1:17: macro parameter `a` repeated"]

[[suites.phase4.cases]]
input = """
#define one(a) ## a
#define two(a) a ##
"""
messages = [
"<case>:1:15: a macro cannot begin nor end with `##`",
"<case>:2:17: a macro cannot begin nor end with `##`",
]

[[suites.phase4.cases]]
input = """
#define one(a) # nonparam
#define two(a) #
#define three(a) # # a
"""
messages = [
  "<case>:1:15: the `#` operator must be followed by a macro parameter",
  "<case>:2:15: the `#` operator must be followed by a macro parameter",
  "<case>:3:17: the `#` operator must be followed by a macro parameter"
]

[[suites.phase4.cases]]
input = '''
#define stringy(a) # a
stringy(3 + 2)
stringy(  three   +   two  )
stringy("a" + "b")
'''
output = '''
"3 + 2"
"three + two"
"\"a\" + \"b\""
'''

[[suites.phase4.cases]]
input = '''
#define concat(a, b) a ## b
concat(one, two)
concat(one, 2)
concat(a, "2")
'''
output = """
onetwo
one2
"""
messages = [
  "<case>:1:23: concatenating `a` and `\"2\"` does not result in a valid preprocessor token",
]

################################################################################
# Test that redefinitions must be equal
################################################################################

[[suites.phase4.cases]]
input = """
#define test A B C
#define test A B C
#define test A  B   C
#define test different
"""
messages = [
  "<case>:2:8: macro `test` was originally defined here: <case>:1:8",
  "<case>:3:8: macro `test` was originally defined here: <case>:1:8",
  "<case>:4:8: macro `test` was originally defined differently here: <case>:1:8"
]

################################################################################
# Test expanding macros
################################################################################

[[suites.phase4.cases]]
input = """
#define abc def
abc abcdef
"""
output = "def abcdef"

[[suites.phase4.cases]]
input = """
#define z z[0]
z
"""
output = "z[0]"

[[suites.phase4.cases]]
input = """
#define test()
test()
"""
output = ""

[[suites.phase4.cases]]
input = """
#define func(a) a
func(1)
func (2)
func
(3)
func (
  4
)
"""
output = "1 2 3 4"

[[suites.phase4.cases]]
input = """
#define noparams() 123
noparams( )
"""
output = "123"

[[suites.phase4.cases]]
input = """
#define add(a, b) a + b
add(1, 3)
"""
output = "1 + 3"

[[suites.phase4.cases]]
input = """
#define object value
#define func() value
object(3)
func
"""
output = "value(3) func"

[[suites.phase4.cases]]
input = """
#define add(a, b) a + b
add(1)
"""
messages = [
  "<case>:2:3: `add` expects exactly 2 arguments; found 1"
]

[[suites.phase4.cases]]
input = """
#define add(a, b) a + b
add(1,2,3)
"""
messages = [
  "<case>:2:3: `add` expects exactly 2 arguments; found 3"
]

[[suites.phase4.cases]]
input = """
#define add(a, b) a + b
add(add(1,2), 3)
"""
output = "1 + 2 + 3"

[[suites.phase4.cases]]
input = """
#define add(a, b, ...) a + b
add(1,2,3,4)
"""
output = "1 + 2"

[[suites.phase4.cases]]
input = """
#define test(a, b, ...) __VA_ARGS__
test(1,2,3,4)
"""
output = "3,4"

[[suites.phase4.cases]]
input = """
#define a b
#define m(a) a
a m(1) a
"""
output = "b 1 b"

[[suites.phase4.cases]]
input = """
#define v(...) __VA_ARGS__
v()
v(1)
v(2, 3)
"""
output = "1 2 , 3"

[[suites.phase4.cases]]
input = """
#define v(a, ...) a
v()
v(0)
v(1, 2)
"""
output = "0 1"
messages = []

[[suites.phase4.cases]]
input = """
#define v(a, b, ...) a
v()
v(0)
v(1, 2)
"""
output = "0 1"
messages = [
  "<case>:2:1: `v` expects at least 2 arguments; found 1",
  "<case>:3:1: `v` expects at least 2 arguments; found 1"
]

[[suites.phase4.cases]]
input = """
#define v(a) a
v()
v(0)
"""
output = "0"
messages = []

# test undef directive

[[suites.phase4.cases]]
input = """
#define a b
a
#undef a
a
"""
output = "b a"

[[suites.phase4.cases]]
input = """
#undef 3
"""
messages = ["<case>:1:7: expected `Identifier` token; found `PPNumber` token"]

[[suites.phase4.cases]]
input = """
#undef 
"""
messages = ["<case>:1:7: expected `Identifier` token; found `Whitespace` token"]

[[suites.phase4.cases]]
input = """
#undef UNDEFINED
"""
messages = ["<case>:1:7: macro `UNDEFINED` does not exist"]

################################################################################
# test cases from the standard
################################################################################

[[suites.phase4.cases]]
input = '''
#define hash_hash # ## #
hash_hash // should result in empty string for WHATEVER reason
a
b hash_hash c // should result in `b ## c`
'''
output = 'a b ## c'

[[suites.phase4.cases]]
# ignored = true
input = '''
#define hash_hash # ## #
#define mkstr(a) # a
#define in_between(a) mkstr(a)
#define join(c, d) in_between(c hash_hash d)
join(x, y) // equivalent to "x ## y"
'''
output = '"x ## y"'

[[suites.phase4.cases]]
input = """
#define m(a) a(w)
#define w 0,1
m(m)
"""
output = "m(0,1)"

[[suites.phase4.cases]]
# ignored = true
input = '''
#define x 3
#define f(a) f(x * (a))
#undef x
#define x 2
#define g f
#define z z[0]
#define h g(\~{ }
#define m(a) a(w)
#define w 0,1
#define t(a) a
#define p() int
#define q(x) x
#define r(x,y) x ## y
#define str(x) # x
f(y+1) + f(f(z)) % t(t(g)(0) + t)(1);
g(x+(3,4)-w) | h 5) & m
      (f)^m(m);
p() i[q()] = { q(1), r(2,3), r(4,), r(,5), r(,) };
char c[2][6] = { str(hello), str() };
'''
output = '''
f(2 * (y+1)) + f(2 * (f(2 * (z[0])))) % f(2 * (0)) + t(1);
f(2 * (2+(3,4)-0,1)) | f(2 * (\~{ } 5)) & f(2 * (0,1))^m(0,1);
int i[] = { 1, 23, 4, 5, };
char c[2][6] = { "hello", "" };
'''

[[suites.phase4.cases]]
input = """
#define func(a) <a>
func     (1)
func     (
2)
func
(3)
"""
output = "<1> <2> <3>"

[[suites.phase4.cases]]
# ignored = true
input = """
#define multiline(a) yes
multiline (
#ifdef multiline
)
#endif
"""
output = "yes"

[[suites.phase4.case]]
input = """
#define test(a) <a>
test (
#define b 1
  b
)
test (
  c
#define c 2
  c
)
test (
  d
#define d 3
  d
#undef d
)
"""
output = """
<1>
<2 2>
<d d>
"""

[[suites.phase4.case]]
input = """
#define NIL(xxx) xxx
#define G_0(arg) NIL(G_1)(arg)
#define G_1(arg) NIL(arg)
G_0(42)
"""
output = "42"

################################################################################
# Random examples I found online
#
# https://blog.robertelder.org/7-weird-old-things-about-the-c-preprocessor/
# http://archive.is/h2tfN
################################################################################

[[suites.phase4.cases]]
# ignored = true
input = """
#define function() 123
#define concat(a,b) a ## b
concat(func,tion)()
"""
output = "123"

[[suites.phase4.cases]]
input = """
#define open (
#define opena (a
#define openacomma (a,
open
opena
openacomma
"""
output = """
(
(a
(a,
"""

[[suites.phase4.cases]]
input = """
#define boo() 123
#define foo(y) boo y )
#define open (
foo(open)
"""
output = "123"


[[suites.phase4.cases]]
# ignored = true
input = """
#define boo() 123
#define foo(x) x #x

foo(boo())
"""
output = '123 "boo()"'

[[suites.phase4.cases]]
input = """
#define recur4(C, T, E) C-T-E
#define recur3(X) [ X ]
#define recur2(C, X) recur4(C(X), recur4(C(X), ,),) |C|
#define recur1(F, X) F(recur3, X)
recur1(recur2, recur1(recur2, 1))
"""
output = """
[ [ 1 ]-[ 1 ]- - - |recur3| ]-[ [ 1 ]-[ 1 ]- - - |recur3| ]- - - |recur3|
"""

################################################################################
# If directives
################################################################################

[[suites.phase4.cases]]
input = """
#if 1
a
#elif 1
b
#else
c
#endif
"""
output = "a"

[[suites.phase4.cases]]
input = """
#if 0
a
#elif 1
b
#else
c
#endif
"""
output = "b"

[[suites.phase4.cases]]
input = """
#if 0
a
#elif 0
b
#else
c
#endif
"""
output = "c"

[[suites.phase4.cases]]
input = """
#if 0
a
#else
b
#endif
"""
output = "b"

[[suites.phase4.cases]]
input = """
#ifdef UNDEFINED
a
#else
b
#endif
"""
output = "b"

[[suites.phase4.cases]]
input = """
#define DEFINED
#ifdef DEFINED
a
#else
b
#endif
"""
output = "a"

[[suites.phase4.cases]]
input = """
#ifdef 3
#endif
#ifndef 2
#else
#endif
"""
messages = [
  "<case>:1:7: expected identifier; found `PPNumber` token",
  "<case>:3:8: expected identifier; found `PPNumber` token"
]

[[suites.phase4.cases]]
input = """
#ifdef test /* whitespace */
#endif
#ifdef test // whitespace
#endif
"""

# Test if-directive expressions
[[suites.phase4.cases]]
input = """
#if defined a
1
#endif

#if defined(a)
2
#endif

#if defined ( a )
3
#endif

#define a

#if defined a
4
#endif
#if defined(a)
5
#endif
#if defined ( a )
6
#endif
"""
output = "4 5 6"

[[suites.phase4.cases]]
input = """
#if defined + a )
#endif

#if defined ( 5 )
#endif

#if defined ( a x
#endif
"""
messages = [
  "<case>:1:12:",
  "<case>:1:12:",
  "<case>:1:12:",
]
